# Definitions for builtins
# These may be moved directly into the compiler at some point

const {
    False=0b
    True=1b
    DATA_SIZE = 0
    OBJ_PTR = 1
    OBJ_ENUM = 2
    OBJ_REFCOUNT = 3
    OBJ_MALLOC = 4
    HEADER_MALLOC = 5
    FALSE = 'False'
    TRUE = 'True'
}

# Forward declarations for functions supplied by platformlib.

def c_free(m:ptr u_mem):bool pass
def c_strlen(str_to_check: ptr u_mem): u_size pass
def c_alloc(bytes:u_size):ptr u_mem pass
def int_to_c_str(my_int:i32): ptr u_mem pass
def c_str_to_int(my_str:str) :i32 pass


# The actual builtins.

# Incr and decr refcount

# def '.obj..__incr__'(my_obj: obj) {
#     var f1 = c_gep(my_obj,0,OBJ_REFCOUNT)
#     var f2 = c_deref(f1)
#     var f3 = f2+=1U
#     unsafe c_ptr_mod(f1, f3)
#     0
# }

# def '.obj..__decr__'(my_obj: obj) {
#     var f1 = c_gep(my_obj,0,OBJ_REFCOUNT)
#     var f2 = c_deref(f1)
#     var f3:u64
#     when f2 > 0U then f3 = f2-=1U
#     unsafe c_ptr_mod(f1, f3)
#     0
# }

def '.header.setobjdata'(my_obj: header, malloc_1:bool, malloc_2:bool, obj_len:u64, my_data_ptr:ptr u_mem): header {
    # Insert the length
    var len_ptr = c_gep(my_obj,DATA_SIZE)
    unsafe c_ptr_mod(len_ptr, obj_len)

    # the object data is malloc'd
    var obj_data_ptr = c_gep(my_obj, OBJ_MALLOC)
    unsafe c_ptr_mod(obj_data_ptr, malloc_1)

    # the object itself is malloc'd
    var h_data_ptr = c_gep(my_obj, HEADER_MALLOC)
    unsafe c_ptr_mod(h_data_ptr, malloc_2)

    # Point to the data
    var data_ptr = c_gep(my_obj, OBJ_PTR)
    unsafe c_ptr_mod(data_ptr, my_data_ptr)

    return my_obj
}


@nomod
def '.object.str.__len__'(my_str:str):u64{    
    var f1 = c_gep(my_str,0,DATA_SIZE)
    c_deref(f1)
}

# TODO: untested
def '.object.array.__del__'(my_obj:ptr u_mem):bool {
    unsafe c_free(my_obj)
}

@nomod
def '.object.str.__index__'(my_str:str, index:i32) :u8 {
    var f1 = c_gep(my_str,0,OBJ_PTR)
    var f2 = c_gep(f1)
    var f3 = c_ptr_math(f2, cast(index,u64))
    c_gep(f3)
}

# TODO: untested

def '.object.str.__del__'(my_str: str):bool {
    var f1 = c_gep(my_str,0,OBJ_MALLOC)
    when c_deref(f1) then {
        # free the data element
        unsafe c_free(c_data(my_str))
    }
    # free the data container
    # TODO: check flag first
    unsafe c_free(c_ptr(my_str))
}



@track
def '.object.str.__new__'(my_obj:ptr u_mem):str {
    # Determine the string length since this is raw data
    var str_len = c_strlen(my_obj)
    
    # Allocate an object of the correct size and type
    var alloc = c_obj_alloc(str)

    # replace with `call`

    call ('.header.setobjdata', 
        unsafe cast(alloc, header),
        False,
        True,
        str_len,
        my_obj
    )

    # # Insert the length
    # var len_ptr = c_gep(alloc,0 ,DATA_SIZE)
    # unsafe c_ptr_mod(len_ptr, str_len)

    # # Point to the data
    # var data_ptr = c_gep(alloc,0, OBJ_PTR)
    # unsafe c_ptr_mod(data_ptr, my_obj)

    # # the object data is not malloc'd (yet)
    # var obj_data_ptr = c_gep(alloc,0, OBJ_MALLOC)
    # unsafe c_ptr_mod(obj_data_ptr, False)

    # # the object itself is malloc'd
    # var h_data_ptr = c_gep(alloc,0, HEADER_MALLOC)
    # unsafe c_ptr_mod(h_data_ptr, True)
    
    # Return the string object
    return alloc
}

@nomod
def '.object.str.__new__'(my_bool: bool):str {
    if my_bool then 'True' else 'False'
    #if my_bool then TRUE else FALSE
}



# TODO: placeholder
def '.object.box.__del__'(my_obj: box):bool {    
    return True
    # only the box object itself should be deleted?
    # need to unpack the original object?
    # call its destructor as well?
}

@track
def '.object.str.__new__'(my_obj:i32):str {
    str(int_to_c_str(my_obj))
}

@nomod
def '.i32.__new__'(my_obj:str):i32 {
    c_str_to_int(my_obj)
}

# TODO:
# string obj eq testing
# test data pointers, length, then the strings themselves

