# Definitions for builtins
# These may be moved directly into the compiler at some point

const {
    False=0b
    True=1b
    DATA_SIZE = 0
    DATA_PTR = 1
    OBJ_ENUM = 2
    OBJ_REFCOUNT = 3
    OBJ_MALLOC = 4
    HEADER_MALLOC = 5
    FALSE = 'False'
    TRUE = 'True'
}

# Forward declarations for functions supplied by platformlib.

def c_free(m:ptr u_mem):bool pass
def c_strlen(str_to_check: ptr u_mem): u_size pass
def c_alloc(bytes:u_size):ptr u_mem pass
def int_to_c_str(my_int:i32): ptr u_mem pass
def c_str_to_int(my_str:str) :i32 pass

# The actual builtins.

# Incr and decr refcount

extern printf(str_fmt :ptr i8, *va) :i32

def '.obj..__incr__'(my_obj: header) {    
    when unsafe cast(my_obj, u64)==0U then return 0
    printf(c_data('Incr'))
    var data_ptr = c_gep(c_gep(my_obj, DATA_PTR))

    var malloc = c_deref(
        c_gep(my_obj, OBJ_MALLOC)
    )

    when malloc then {
        var f1 = c_gep(my_obj,OBJ_REFCOUNT)
        var f2 = c_deref(f1)        
        var f3 = f2+=1U
        #printf(c_data('Count is now: %u'),f3)
        unsafe c_ptr_mod(f1, f3)
    }
    1
}

def '.obj..__decr__'(my_obj_ptr: ptr u_mem, my_obj:header) {
    print ("Enter decr")
    print ("1:", unsafe cast(my_obj_ptr, u64))
    print ("2:", c_deref(unsafe cast(my_obj_ptr, ptr u_size)))
    
    when unsafe cast(my_obj_ptr, u64)==0U then {
        printf(c_data("Addr unfound for decr"))
        return 0
    }

    #when unsafe cast(my_obj, u64)==0U then return 0
   

    var f1 = c_gep(my_obj,OBJ_REFCOUNT)
    var f2 = c_deref(f1) 
    var f3:u64=0U
    when f2>0U then {
        f3=f2-=1U
        unsafe c_ptr_mod(f1, f3)
    }
    #var data_ptr = c_gep(c_gep(my_obj, DATA_PTR))
    1
}

def '.obj.._free'(my_obj_ptr: ptr u_mem, my_obj:header) {
    #print ("Enter free")
    #print ("1:", unsafe cast(my_obj_ptr, u64))
    #print ("2:", c_deref(unsafe cast(my_obj_ptr, ptr u_size)))
    #print ("3:", unsafe cast(my_obj, u64))


    when unsafe cast(my_obj_ptr, u64)==0U then {
        #printf(c_data("Addr unfound for free"))
        return 0
    }

    var f1 = c_gep(my_obj,OBJ_REFCOUNT)
    var f3 = c_deref(f1) 
    when f3==0U then {
        var obj_malloc_ptr = c_gep(my_obj, OBJ_MALLOC)
        var obj_malloc = c_deref(obj_malloc_ptr)
        when obj_malloc then {
            var data_ptr = c_gep(c_gep(my_obj, DATA_PTR))
            unsafe c_free(data_ptr)
        }
        var h_data_ptr = c_gep(my_obj, HEADER_MALLOC)
        var h_data = c_deref(h_data_ptr)
        when h_data then {
            unsafe c_free(cast(my_obj, ptr u_mem))
        }
        var z = cast(c_deref(my_obj_ptr), u_size)
        z=0U
        #print ("Free ",z)

        #var z = cast(my_obj_ptr, ptr u_size)
        #var t = c_deref(z)
        #t = 0U
        #unsafe c_ptr_mod(z, 0U)
        #z = cast(0U, ptr u_size)
        #t=0U
        #printf(c_data('Free'))
        #print ("Free",z)
    }
    1
}


def '.header._setdata'(my_obj: header, malloc_1:bool, malloc_2:bool, obj_len:u64, my_data_ptr:ptr u_mem): header {
    # Insert the length
    var len_ptr = c_gep(my_obj,DATA_SIZE)
    unsafe c_ptr_mod(len_ptr, obj_len)

    # the object data is malloc'd
    var obj_data_ptr = c_gep(my_obj, OBJ_MALLOC)
    unsafe c_ptr_mod(obj_data_ptr, malloc_1)

    # the object itself is malloc'd
    var h_data_ptr = c_gep(my_obj, HEADER_MALLOC)
    unsafe c_ptr_mod(h_data_ptr, malloc_2)

    # Point to the data
    var data_ptr = c_gep(my_obj, DATA_PTR)
    unsafe c_ptr_mod(data_ptr, my_data_ptr)

    var count_ptr = c_gep(my_obj, OBJ_REFCOUNT)    
    unsafe c_ptr_mod(count_ptr, 0U)

    return my_obj
}


### STR ###

### new

@track
def '.object.str.__new__'(my_obj:ptr u_mem):str {
    # This assumes the underlying data has been malloc'd;
    # we'll add a flag later for that

    # Determine the string length since this is raw data
    var str_len = c_strlen(my_obj)
    
    # Allocate an object of the correct size and type
    var alloc = c_obj_alloc(str)

    call ('.header._setdata', 
        unsafe cast(alloc, header),
        True,
        True,
        str_len,
        my_obj
    )

    # Return the string object
    return alloc
}

@nomod
def '.object.str.__new__'(my_bool: bool):str {
    if my_bool then 'True' else 'False'
    #if my_bool then TRUE else FALSE
}

@track
def '.object.str.__new__'(my_obj:i32):str {
    str(int_to_c_str(my_obj))
}


## other str functions

@nomod
def '.object.str.__len__'(my_str:str):u64{    
    var f1 = c_gep(my_str,0,DATA_SIZE)
    c_deref(f1)
}

@nomod
def '.object.str.__index__'(my_str:str, index:i64) :u8 {
    var f1 = c_gep(my_str,0,DATA_PTR)
    var f2 = c_gep(f1)
    var f3 = c_ptr_math(f2, cast(index,u64))
    c_gep(f3)
}

def '.object.str.__index__'(my_str:str, index:i32) :u8 {
    my_str[convert(index,i64)]
}


@nomod
def '.i32.__new__'(my_obj:str):i32 {
    c_str_to_int(my_obj)
}

# TODO:
# string obj eq testing
# test data pointers, length, then the strings themselves







### DELETED / DEFERRED

# TODO: untested
#def '.object.array.__del__'(my_obj:ptr u_mem):bool {
    #unsafe c_free(my_obj)
#}

# TODO: placeholder
#def '.object.box.__del__'(my_obj: box):bool {    
    #return True
    # only the box object itself should be deleted?
    # need to unpack the original object?
    # call its destructor as well?
#}

#def '.object.str.__del__'(my_str: str):bool {
    #var f1 = c_gep(my_str,0,OBJ_MALLOC)
    #when c_deref(f1) then {
        # free the data element
        #unsafe c_free(c_data(my_str))
    #}
    # free the data container
    # TODO: check flag first
    #unsafe c_free(c_ptr_mem(my_str))
#}