# Definitions for builtins
# These may be moved directly into the compiler at some point

const {
    False=0b
    True=1b
    ELEMENT_LEN = 0
    ELEMENT_PTR = 1
    ELEMENT_REFCOUNT = 2
    ELEMENT_PTR_ALLOC = 3
    ELEMENT_ALLOC = 4
    FALSE = 'False'
    TRUE = 'True'
}

# Forward declarations for functions supplied by platformlib.

def c_free(m:ptr u_mem):bool pass
def c_strlen(str_to_check: ptr u_mem): u_size pass
def c_alloc(bytes:u_size):ptr u_mem pass
def int_to_c_str(my_int:i32): ptr u_mem pass
def c_str_to_int(my_str:str) :i32 pass

# The actual builtins.

@nomod
def '.object.str.__len__'(my_str:str):u64{    
    var f1 = c_gep(my_str,0,ELEMENT_LEN)
    c_deref(f1)
}

# TODO: untested
def '.object.array.__del__'(my_obj:ptr u_mem):bool {
    unsafe c_free(my_obj)
}

@nomod
def '.object.str.__index__'(my_str:str, index:i32) :u8 {
    var f1 = c_gep(my_str,0,ELEMENT_PTR)
    var f2 = c_gep(f1)
    var f3 = c_ptr_math(f2, cast(index,u64))
    c_gep(f3)
}

# TODO: untested

def '.object.str.__del__'(my_str: str):bool {
    var f1 = c_gep(my_str,0,ELEMENT_PTR_ALLOC)
    when c_deref(f1) then {
        # free the data element
        unsafe c_free(c_data(my_str))
    }
    # free the data container
    # TODO: check flag first
    unsafe c_free(c_ptr(my_str))
}

@track
def '.object.str.__new__'(my_obj:ptr u_mem):str {
    # Determine the string length since this is raw data
    var str_len = c_strlen(my_obj)
    
    # Allocate an object of the correct size and type
    var alloc = c_obj_alloc(str)

    # Insert the length
    var len_ptr = c_gep(alloc,0 ,ELEMENT_LEN)
    unsafe c_ptr_mod(len_ptr, str_len)

    # Point to the data
    var data_ptr = c_gep(alloc,0, ELEMENT_PTR)
    unsafe c_ptr_mod(data_ptr, my_obj)

    # the object data is not malloc'd (yet)
    var obj_data_ptr = c_gep(alloc,0, ELEMENT_PTR_ALLOC)
    unsafe c_ptr_mod(obj_data_ptr, False)

    # the object itself is malloc'd
    var h_data_ptr = c_gep(alloc,0, ELEMENT_ALLOC)
    unsafe c_ptr_mod(h_data_ptr, True)
    
    # Return the string object
    return alloc
}

@nomod
def '.object.str.__new__'(my_bool: bool):str {
    if my_bool then 'True' else 'False'
    #if my_bool then TRUE else FALSE
}

def set_obj(my_obj:obj, malloc_1:bool, malloc_2:bool, obj_len:u64, my_data_ptr:ptr u_mem):obj {
    # Insert the length
    var len_ptr = c_gep(my_obj,0 ,ELEMENT_LEN)
    unsafe c_ptr_mod(len_ptr, obj_len)

    # the object data is malloc'd
    var obj_data_ptr = c_gep(my_obj,0, ELEMENT_PTR_ALLOC)
    unsafe c_ptr_mod(obj_data_ptr, malloc_1)

    # the object itself is malloc'd
    var h_data_ptr = c_gep(my_obj,0, ELEMENT_ALLOC)
    unsafe c_ptr_mod(h_data_ptr, malloc_2)

    # Point to the data
    var data_ptr = c_gep(my_obj,0, ELEMENT_PTR)
    unsafe c_ptr_mod(data_ptr, my_data_ptr)

    return my_obj
}

# TODO: placeholder
def '.object.obj.__del__'(my_obj: obj):bool {    
    return True
    # only the box object itself should be deleted?
    # need to unpack the original object?
    # call its destructor as well?
}

@track
def '.object.str.__new__'(my_obj:i32):str {
    str(int_to_c_str(my_obj))
}

@nomod
def '.i32.__new__'(my_obj:str):i32 {
    c_str_to_int(my_obj)
}

# TODO:
# string obj eq testing
# test data pointers, length, then the strings themselves

