# Definitions for builtins
# These may be moved directly into the compiler at some point

const {
    False=0b
    True=1b
    ELEMENT_LEN = 0
    ELEMENT_PTR = 1
    ELEMENT_REFCOUNT = 2 
    ELEMENT_PTR_ALLOC = 3
    ELEMENT_ALLOC = 4
}

# Forward declarations for functions supplied by platformlib.

def c_free(m:ptr u_mem):bool pass
def c_strlen(str_to_check: ptr u_mem): u_size pass
def c_alloc(bytes:u_size):ptr u_mem pass
def int_to_c_str(my_int:i32): ptr u_mem pass
def c_str_to_int(my_str:str) :i32 pass

# The actual builtins.

@nomod
def '.object.str.__len__'(my_str:str):u64{    
    var f1 = c_gep(my_str,0,ELEMENT_LEN)
    c_deref(f1)
}

# TODO: untested
def '.object.array.__del__'(my_obj:ptr u_mem):bool {
    unsafe c_free(my_obj)
}

@nomod
def '.object.str.__index__'(my_str:str, index:i32) :u8 {
    var f1 = c_gep(my_str,0,ELEMENT_PTR)
    var f2 = c_gep(f1)
    var f3 = c_ptr_math(f2, cast(index,u64))
    c_gep(f3)
}

# TODO: untested

def '.object.str.__del__'(my_str: str):bool {
    var f1 = c_gep(my_str,0,ELEMENT_PTR_ALLOC)
    when c_deref(f1) then {
        # free the data element
        unsafe c_free(c_data(my_str))
    }
    # free the data container
    # TODO: check flag first
    unsafe c_free(c_ptr(my_str))
}

@track
def '.object.str.__new__'(my_obj:ptr u_mem):str {
    # Determine the string length since this is raw data
    var str_len = c_strlen(my_obj)
    
    # Allocate an object of the correct size and type
    var alloc = c_obj_alloc(str)

    # Insert the length
    var len_ptr = c_gep(alloc,0 ,ELEMENT_LEN)
    unsafe c_ptr_mod(len_ptr, str_len)

    # Point to the data
    var data_ptr = c_gep(alloc,0, ELEMENT_PTR)
    unsafe c_ptr_mod(data_ptr, my_obj)

    # the object data is not malloc'd (yet)
    var obj_data_ptr = c_gep(alloc,0, ELEMENT_PTR_ALLOC)
    unsafe c_ptr_mod(obj_data_ptr, False)

    # the object itself is malloc'd
    var h_data_ptr = c_gep(alloc,0, ELEMENT_ALLOC)
    unsafe c_ptr_mod(h_data_ptr, True)
    
    # Return the string object
    return alloc

}

@track
def '.object.obj.__new__'(my_obj:i32):obj {
    # Allocate an object of the correct size
    var obj_alloc = c_obj_alloc(obj)
    
    # Allocate space for the variable to be stored
    var my_obj_alloc = c_obj_alloc(i32)
    my_obj_alloc = my_obj

    # Insert the length
    var len_ptr = c_gep(obj_alloc,0 ,ELEMENT_LEN)
    unsafe c_ptr_mod(len_ptr, c_size(my_obj))

    # the object data is malloc'd
    var obj_data_ptr = c_gep(obj_alloc,0, ELEMENT_PTR_ALLOC)
    unsafe c_ptr_mod(obj_data_ptr, True)

    # the object itself is malloc'd
    var h_data_ptr = c_gep(obj_alloc,0, ELEMENT_ALLOC)
    unsafe c_ptr_mod(h_data_ptr, True)

    # Point to the data
    var data_ptr = c_gep(obj_alloc,0, ELEMENT_PTR)
    unsafe c_ptr_mod(data_ptr, c_ptr(c_ref(my_obj_alloc)))
    
    return obj_alloc
}

@track
def '.object.str.__new__'(my_obj:i32):str {
    str(int_to_c_str(my_obj))
}

def '.i32.__new__'(my_obj:str):i32 {
    c_str_to_int(my_obj)
}

# TODO:
# string obj eq testing
# test data pointers, length, then the strings themselves

